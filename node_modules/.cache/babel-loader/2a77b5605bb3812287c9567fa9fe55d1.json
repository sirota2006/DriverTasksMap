{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _server = require('react-dom/server');\n\nvar _server2 = _interopRequireDefault(_server);\n\nrequire('./ReactBingmaps.css');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar map = {},\n    Microsoft,\n    infobox = {},\n    scriptURL = \"https://www.bing.com/api/maps/mapcontrol?callback=bingmapsCallback\",\n    pendingProps = [];\n\nvar ReactBingmaps = function (_Component) {\n  _inherits(ReactBingmaps, _Component);\n\n  function ReactBingmaps(props) {\n    _classCallCheck(this, ReactBingmaps);\n\n    var _this = _possibleConstructorReturn(this, (ReactBingmaps.__proto__ || Object.getPrototypeOf(ReactBingmaps)).call(this, props));\n\n    if (document.querySelector('script[src=\"' + scriptURL + '\"]') === null) {\n      _this.loadScript(scriptURL);\n\n      window.bingmapsCallback = function () {\n        Microsoft = window.Microsoft;\n        this.afterDependencyLoad(pendingProps);\n      }.bind(_this);\n    }\n\n    return _this;\n  }\n\n  _createClass(ReactBingmaps, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (Microsoft === null || Microsoft === undefined) {\n        pendingProps.push(this.props);\n      } else {\n        this.reactBingmaps(this.props, Microsoft);\n      }\n    }\n  }, {\n    key: 'afterDependencyLoad',\n    value: function afterDependencyLoad(pendingProps) {\n      var _this2 = this;\n\n      try {\n        pendingProps.map(function (props) {\n          return _this2.reactBingmaps(props, Microsoft);\n        });\n      } catch (exception) {\n        console.log(\"Error loading Microsoft bingmaps\");\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      try {\n        var mapReference = this.props.id ? '#' + this.props.id : '.react-bingmaps';\n        if (map[mapReference]) //map[mapReference].dispose();\n          map[mapReference] = undefined;\n        infobox = {};\n        pendingProps = [];\n      } catch (exception) {\n        console.log(exception);\n      }\n    }\n  }, {\n    key: 'loadScript',\n    value: function loadScript(url) {\n      var script = document.createElement(\"script\");\n      script.type = \"text/javascript\";\n      script.async = true;\n      script.defer = true;\n      script.src = url;\n      document.getElementsByTagName(\"head\")[0].appendChild(script);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var mapReference = nextProps.id ? '#' + nextProps.id : '.react-bingmaps';\n\n      if (this.props.center.join() !== nextProps.center.join()) {\n        this.setMapCenter(nextProps.center, mapReference);\n      }\n\n      if (this.props.zoom !== nextProps.zoom) {\n        this.setMapZoom(nextProps.zoom, mapReference);\n      }\n\n      if (this.props.mapTypeId !== nextProps.mapTypeId) {\n        this.setMapTypeId(nextProps.mapTypeId, nextProps.center, nextProps.heading, mapReference);\n      }\n\n      if (this.props.navigationBarMode !== nextProps.navigationBarMode) {\n        this.setMapNavigationBarMode(nextProps.navigationBarMode, mapReference);\n      }\n\n      if (this.props.supportedMapTypes !== nextProps.supportedMapTypes) {\n        this.setMapSupportedMapTypes(nextProps.supportedMapTypes, mapReference);\n      }\n\n      if (this.props.disableStreetside !== nextProps.disableStreetside) {\n        this.setDisableStreetside(nextProps.disableStreetside, mapReference);\n      }\n\n      if (this.props.pushPins !== nextProps.pushPins) {\n        this.setPushPins(nextProps.pushPins, mapReference);\n      }\n\n      if (this.props.infoboxes !== nextProps.infoboxes) {\n        this.setInfoboxes(nextProps.infoboxes, \"infoboxes\", mapReference);\n      }\n\n      if (this.props.infoboxesWithPushPins !== nextProps.infoboxesWithPushPins) {\n        this.setInfoboxesWithPushPins(nextProps.infoboxesWithPushPins, \"infoboxesWithPushPins\", mapReference);\n      }\n\n      if (this.props.regularPolygons !== nextProps.regularPolygons) {\n        this.createRegularPolygons(nextProps.regularPolygons, mapReference);\n      }\n\n      if (this.props.boundary !== nextProps.boundary) {\n        this.setBoundary(nextProps.boundary, mapReference);\n      }\n\n      if (this.props.mapOptions !== nextProps.mapOptions) {\n        this.setMapOptions(nextProps.mapOptions, mapReference);\n      }\n\n      if (this.props.polyline !== nextProps.polyline) {\n        this.setPolyline(nextProps.polyline, mapReference);\n      }\n\n      if (this.props.directions !== nextProps.directions) {\n        this.setDirections(nextProps.directions, mapReference);\n      }\n    }\n  }, {\n    key: 'reactBingmaps',\n    value: function reactBingmaps(props, Microsoft) {\n      var bingmapKey = props.bingmapKey,\n          center = props.center,\n          mapTypeId = props.mapTypeId,\n          zoom = props.zoom,\n          navigationBarMode = props.navigationBarMode,\n          supportedMapTypes = props.supportedMapTypes,\n          heading = props.heading,\n          pushPins = props.pushPins,\n          disableStreetside = props.disableStreetside,\n          infoboxes = props.infoboxes,\n          infoboxesWithPushPins = props.infoboxesWithPushPins,\n          getLocation = props.getLocation,\n          regularPolygons = props.regularPolygons,\n          boundary = props.boundary,\n          mapOptions = props.mapOptions,\n          polyline = props.polyline,\n          directions = props.directions,\n          mapHandlers = props.mapHandlers;\n\n      if (bingmapKey && Microsoft) {\n        var mapReference = props.id ? '#' + props.id : '.react-bingmaps';\n\n        if (!map[mapReference]) {\n          map[mapReference] = new Microsoft.Maps.Map(mapReference, {\n            credentials: bingmapKey\n          });\n        }\n\n        this.setMapCenter(center, mapReference);\n        this.setMapTypeId(mapTypeId, center, heading, mapReference);\n        this.setMapZoom(zoom, mapReference);\n        this.setMapNavigationBarMode(navigationBarMode, mapReference);\n        this.setMapSupportedMapTypes(supportedMapTypes, mapReference);\n        this.setDisableStreetside(disableStreetside, mapReference);\n        this.setPushPins(pushPins, mapReference);\n        this.setInfoboxes(infoboxes, \"infoboxes\", mapReference);\n        this.setInfoboxesWithPushPins(infoboxesWithPushPins, \"infoboxesWithPushPins\", mapReference);\n        this.setGetLocation(getLocation, mapReference);\n        this.createRegularPolygons(regularPolygons, mapReference);\n        this.setBoundary(boundary, mapReference);\n        this.setMapOptions(mapOptions, mapReference);\n        this.setPolyline(polyline, mapReference);\n        this.setDirections(directions, mapReference);\n        this.setMapHandlers(mapHandlers, mapReference);\n      }\n    }\n  }, {\n    key: 'setMapCenter',\n    value: function setMapCenter(center, mapReference) {\n      if (map[mapReference] && center && center[0] && center[1]) {\n        map[mapReference].setView({\n          center: new Microsoft.Maps.Location(center[0], center[1])\n        });\n      }\n    }\n  }, {\n    key: 'setMapTypeId',\n    value: function setMapTypeId(mapTypeId, center, heading, mapReference) {\n      if (map[mapReference] && mapTypeId) {\n        var isBirdEyeAvailable = false;\n\n        if (mapTypeId === \"birdseye\" && center && center[0] && center[1]) {\n          var location = new Microsoft.Maps.Location(center[0], center[1]);\n          Microsoft.Maps.getIsBirdseyeAvailable(location, Microsoft.Maps.Heading[heading], function (onResponse) {\n            isBirdEyeAvailable = onResponse;\n          });\n        }\n\n        if (mapTypeId) {\n          map[mapReference].setView({\n            mapTypeId: isBirdEyeAvailable ? Microsoft.Maps.MapTypeId.birdseye : Microsoft.Maps.MapTypeId[mapTypeId]\n          });\n        }\n      }\n    }\n  }, {\n    key: 'setMapZoom',\n    value: function setMapZoom(zoom, mapReference) {\n      if (map[mapReference] && zoom) {\n        map[mapReference].setView({\n          zoom: zoom\n        });\n      }\n    }\n  }, {\n    key: 'setMapNavigationBarMode',\n    value: function setMapNavigationBarMode(navigationBarMode, mapReference) {\n      if (map[mapReference] && navigationBarMode) {\n        map[mapReference].setView({\n          navigationBarMode: navigationBarMode\n        });\n      }\n    }\n  }, {\n    key: 'setMapSupportedMapTypes',\n    value: function setMapSupportedMapTypes(supportedMapTypes, mapReference) {\n      if (map[mapReference] && supportedMapTypes) {\n        map[mapReference].setView({\n          supportedMapTypes: supportedMapTypes.map(function (id) {\n            return Microsoft.Maps.MapTypeId[id];\n          })\n        });\n      }\n    }\n  }, {\n    key: 'setDisableStreetside',\n    value: function setDisableStreetside(disableStreetside, mapReference) {\n      if (map[mapReference] && disableStreetside) {\n        map[mapReference].setView({\n          disableStreetside: disableStreetside\n        });\n      }\n    }\n  }, {\n    key: 'setPushPins',\n    value: function setPushPins(pushPins, mapReference) {\n      if (map[mapReference] && pushPins) {\n        for (var i = map[mapReference].entities.getLength() - 1; i >= 0; i--) {\n          var pushpin = map[mapReference].entities.get(i);\n\n          if (pushpin instanceof Microsoft.Maps.Pushpin) {\n            map[mapReference].entities.removeAt(i);\n          }\n        }\n\n        for (var pushPinIndex = 0; pushPinIndex < pushPins.length; pushPinIndex++) {\n          if (pushPins[pushPinIndex].location && pushPins[pushPinIndex].location[0] && pushPins[pushPinIndex].location[1]) {\n            var location = new Microsoft.Maps.Location(pushPins[pushPinIndex].location[0], pushPins[pushPinIndex].location[1]);\n            var option = pushPins[pushPinIndex].option ? pushPins[pushPinIndex].option : null;\n\n            if (option && option.anchor && option.anchor[0] && option.anchor[1]) {\n              option.anchor = new Microsoft.Maps.Point(option.anchor[0], option.anchor[1]);\n            }\n\n            var _pushpin = new Microsoft.Maps.Pushpin(location, option);\n\n            map[mapReference].entities.push(_pushpin);\n\n            if (pushPins[pushPinIndex].addHandler) {\n              Microsoft.Maps.Events.addHandler(_pushpin, pushPins[pushPinIndex].addHandler.type, function (callback, data) {\n                this.MakeCallback(callback, data);\n              }.bind(this, pushPins[pushPinIndex].addHandler.callback, pushPins[pushPinIndex].addHandler.callbackData));\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'setInfoboxes',\n    value: function setInfoboxes(infoboxes, infoboxCreateType, mapReference) {\n      if (map[mapReference] && infoboxes) {\n        for (var i = 0; infobox[infoboxCreateType] && i < infobox[infoboxCreateType].length; i++) {\n          infobox[infoboxCreateType][i].setMap(null);\n        }\n\n        infobox[infoboxCreateType] = [];\n\n        if (infoboxes) {\n          for (var infoboxIndex = 0; infoboxIndex < infoboxes.length; infoboxIndex++) {\n            if (infoboxes[infoboxIndex].location && infoboxes[infoboxIndex].location[0] && infoboxes[infoboxIndex].location[1]) {\n              var location = new Microsoft.Maps.Location(infoboxes[infoboxIndex].location[0], infoboxes[infoboxIndex].location[1]);\n              var option = infoboxes[infoboxIndex] ? infoboxes[infoboxIndex].option : null;\n\n              if (option.htmlContent) {\n                option.htmlContent = _server2.default.renderToStaticMarkup(option.htmlContent);\n              }\n\n              infobox[infoboxCreateType].push(new Microsoft.Maps.Infobox(location, option));\n              infobox[infoboxCreateType][infoboxIndex].setMap(map[mapReference]);\n\n              if (infoboxes[infoboxIndex].addHandler) {\n                Microsoft.Maps.Events.addHandler(infobox[infoboxCreateType][infoboxIndex], infoboxes[infoboxIndex].addHandler.type, function (callback, data) {\n                  this.MakeCallback(callback, data);\n                }.bind(this, infoboxes[infoboxIndex].addHandler.callback, infoboxes[infoboxIndex].addHandler.callbackData));\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'setInfoboxesWithPushPins',\n    value: function setInfoboxesWithPushPins(infoboxesWithPushPins, infoboxCreateType, mapReference) {\n      if (map[mapReference] && infoboxesWithPushPins) {\n        //Remove existing Infoboxes\n        var i;\n\n        for (i = 0; infobox[infoboxCreateType] && i < infobox[infoboxCreateType].length; i++) {\n          infobox[infoboxCreateType][i].setMap(null);\n        } //Remove existing Pushpins\n\n\n        for (i = map[mapReference].entities.getLength() - 1; i >= 0; i--) {\n          var pushpin = map[mapReference].entities.get(i);\n\n          if (pushpin instanceof Microsoft.Maps.Pushpin) {\n            map[mapReference].entities.removeAt(i);\n          }\n        }\n\n        infobox[infoboxCreateType] = []; //Add Infoboxes with Pushpins\n\n        if (infoboxesWithPushPins) {\n          for (var infoboxWithPushPinIndex = 0; infoboxWithPushPinIndex < infoboxesWithPushPins.length; infoboxWithPushPinIndex++) {\n            if (infoboxesWithPushPins[infoboxWithPushPinIndex].location) {\n              //Set Location\n              var location = new Microsoft.Maps.Location(infoboxesWithPushPins[infoboxWithPushPinIndex].location[0], infoboxesWithPushPins[infoboxWithPushPinIndex].location[1]); //Set Infobox Option\n\n              var infoboxOption = infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxOption ? infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxOption : null; //ConvertToHtml if Obj\n\n              if (infoboxOption.htmlContent) {\n                infoboxOption.htmlContent = _server2.default.renderToStaticMarkup(infoboxOption.htmlContent);\n              } //If Handler added, initially hide Infobox\n\n\n              if (infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler) {\n                infoboxOption[\"visible\"] = false;\n              } //Set Pushpin Option\n\n\n              var pushPinOption = infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinOption ? infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinOption : null; //Initilize if anchor for Pushpin\n\n              if (pushPinOption.anchor && pushPinOption.anchor[0] && pushPinOption.anchor[1]) {\n                pushPinOption.anchor = new Microsoft.Maps.Point(pushPinOption.anchor[0], pushPinOption.anchor[1]);\n              } //Set Infobox\n\n\n              infobox[infoboxCreateType].push(new Microsoft.Maps.Infobox(location, infoboxOption));\n              infobox[infoboxCreateType][infoboxWithPushPinIndex].setMap(map[mapReference]); //Set Infobox Callback if any\n\n              if (infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler) {\n                Microsoft.Maps.Events.addHandler(infobox[infoboxCreateType][infoboxWithPushPinIndex], infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.type, function (callback, data) {\n                  this.MakeCallback(callback, data);\n                }.bind(this, infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.callback, infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.callbackData));\n              } //Set Pushpin\t\t\t\t\n\n\n              var _pushpin2 = new Microsoft.Maps.Pushpin(location, pushPinOption);\n\n              map[mapReference].entities.push(_pushpin2); //Set Pushpin Callback if any\n\n              if (infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler) {\n                Microsoft.Maps.Events.addHandler(_pushpin2, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.type, function (callback, data) {\n                  this.MakeCallback(callback, data);\n                }.bind(this, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.callback, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.callbackData));\n              } //Set InfoboxesWithPushPins handler if any\n\n\n              if (infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler) {\n                this.setInfoboxesWithPushPinsHandler(infobox[infoboxCreateType][infoboxWithPushPinIndex], _pushpin2, infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler);\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'setGetLocation',\n    value: function setGetLocation(getLocation, mapReference) {\n      if (map[mapReference] && getLocation) {\n        if (getLocation.addHandler) {\n          Microsoft.Maps.Events.addHandler(map[mapReference], getLocation.addHandler, function (callback, e) {\n            if (typeof e.getX !== \"undefined\" && typeof e.getY !== \"undefined\") {\n              var point = new Microsoft.Maps.Point(e.getX(), e.getY());\n              var location = e.target.tryPixelToLocation(point);\n              this.MakeCallback(callback, location);\n            } else {\n              this.MakeCallback(callback, \"Event: \" + getLocation.addHandler);\n            }\n          }.bind(this, getLocation.callback));\n        } else {\n          Microsoft.Maps.Events.addHandler(map[mapReference], \"click\", function (callback, e) {\n            if (typeof e.getX !== \"undefined\" && typeof e.getY !== \"undefined\") {\n              var point = new Microsoft.Maps.Point(e.getX(), e.getY());\n              var location = e.target.tryPixelToLocation(point);\n              this.MakeCallback(callback, location);\n            } else {\n              this.MakeCallback(callback, \"Event: \" + getLocation.addHandler);\n            }\n          }.bind(this, getLocation.callback));\n        }\n      }\n    }\n  }, {\n    key: 'setInfoboxesWithPushPinsHandler',\n    value: function setInfoboxesWithPushPinsHandler(infobox, pushpin, addHandler, mapReference) {\n      if (addHandler === \"mouseover\") {\n        Microsoft.Maps.Events.addHandler(pushpin, addHandler, function () {\n          infobox.setOptions({\n            visible: true\n          });\n        });\n        Microsoft.Maps.Events.addHandler(pushpin, \"mouseout\", function () {\n          infobox.setOptions({\n            visible: false\n          });\n        });\n      } else {\n        Microsoft.Maps.Events.addHandler(pushpin, addHandler, function () {\n          infobox.setOptions({\n            visible: true\n          });\n        });\n      }\n    }\n  }, {\n    key: 'MakeCallback',\n    value: function MakeCallback(callback, data, mapReference) {\n      data ? callback(data) : callback();\n    }\n  }, {\n    key: 'createRegularPolygons',\n    value: function createRegularPolygons(regularPolygons, mapReference) {\n      if (map[mapReference] && regularPolygons) {\n        for (var i = map[mapReference].entities.getLength() - 1; i >= 0; i--) {\n          var regularPolygon = map[mapReference].entities.get(i);\n\n          if (regularPolygon instanceof Microsoft.Maps.Polygon) {\n            map[mapReference].entities.removeAt(i);\n          }\n        }\n\n        for (var regularPolygonIndex = 0; regularPolygonIndex < regularPolygons.length; regularPolygonIndex++) {\n          if (regularPolygons[regularPolygonIndex].center && regularPolygons[regularPolygonIndex].center[0] && regularPolygons[regularPolygonIndex].center[1]) {\n            (function () {\n              var location = new Microsoft.Maps.Location(regularPolygons[regularPolygonIndex].center[0], regularPolygons[regularPolygonIndex].center[1]);\n              var radius = regularPolygons[regularPolygonIndex].radius ? regularPolygons[regularPolygonIndex].radius : 0;\n              var points = regularPolygons[regularPolygonIndex].points ? regularPolygons[regularPolygonIndex].points : 0;\n              var option = regularPolygons[regularPolygonIndex].option ? regularPolygons[regularPolygonIndex].option : {};\n              Microsoft.Maps.loadModule('Microsoft.Maps.SpatialMath', function () {\n                var locations = Microsoft.Maps.SpatialMath.getRegularPolygon(location, radius, points, Microsoft.Maps.SpatialMath.DistanceUnits.Miles);\n                var polygon = new Microsoft.Maps.Polygon(locations, option);\n                map[mapReference].entities.push(polygon);\n              });\n            })();\n          }\n        }\n      }\n    }\n  }, {\n    key: 'setBoundary',\n    value: function setBoundary(boundary, mapReference) {\n      if (map[mapReference] && boundary) {\n        for (var i = map[mapReference].entities.getLength() - 1; i >= 0; i--) {\n          var regularPolygon = map[mapReference].entities.get(i);\n\n          if (regularPolygon instanceof Microsoft.Maps.Polygon) {\n            map[mapReference].entities.removeAt(i);\n          }\n        } // var boundaryLocation;\n        // if(boundary.option && \n        // \tboundary.option.entityType && \n        // \t\t!(boundary.option.entityType.includes(\"Postcode\"))){\n        // \tboundaryLocation = new Microsoft.Maps.Location(boundary.location[0], boundary.location[1]);\n        // }\n        // else{\n        // \tboundaryLocation = boundary.location\n        // }\n\n\n        var boundaryLocation = boundary.location ? boundary.location : null;\n        var geoDataRequestOptions = boundary.option ? boundary.option : {};\n        var polygonStyle = boundary.polygonStyle ? boundary.polygonStyle : null;\n        var search = boundary.search ? boundary.search : null;\n\n        if (!search && boundaryLocation) {\n          Microsoft.Maps.loadModule('Microsoft.Maps.SpatialDataService', function () {\n            Microsoft.Maps.SpatialDataService.GeoDataAPIManager.getBoundary(boundaryLocation, geoDataRequestOptions, map[mapReference], function (data) {\n              if (data.results && data.results.length > 0) {\n                map[mapReference].entities.push(data.results[0].Polygons);\n              }\n            }, polygonStyle, function errCallback(networkStatus, statusMessage) {\n              console.log(networkStatus);\n              console.log(statusMessage);\n            });\n          });\n        } else {\n          Microsoft.Maps.loadModule(['Microsoft.Maps.SpatialDataService', 'Microsoft.Maps.Search'], function () {\n            var searchManager = new Microsoft.Maps.Search.SearchManager(map[mapReference]);\n            var geocodeRequest = {\n              where: search,\n              callback: function callback(geocodeResult) {\n                if (geocodeResult && geocodeResult.results && geocodeResult.results.length > 0) {\n                  map[mapReference].setView({\n                    bounds: geocodeResult.results[0].bestView\n                  });\n                  Microsoft.Maps.SpatialDataService.GeoDataAPIManager.getBoundary(geocodeResult.results[0].location, geoDataRequestOptions, map[mapReference], function (data) {\n                    if (data.results && data.results.length > 0) {\n                      map[mapReference].entities.push(data.results[0].Polygons);\n                    }\n                  }, polygonStyle, function errCallback(networkStatus, statusMessage) {\n                    console.log(networkStatus);\n                    console.log(statusMessage);\n                  });\n                }\n              }\n            };\n            searchManager.geocode(geocodeRequest);\n          });\n        }\n      }\n    }\n  }, {\n    key: 'setMapOptions',\n    value: function setMapOptions(mapOptions, mapReference) {\n      if (map[mapReference] && mapOptions) {\n        map[mapReference].setOptions(mapOptions);\n      }\n    }\n  }, {\n    key: 'setPolyline',\n    value: function setPolyline(polyline, mapReference) {\n      if (map[mapReference] && polyline) {\n        for (var i = map[mapReference].entities.getLength() - 1; i >= 0; i--) {\n          var ref = map[mapReference].entities.get(i);\n\n          if (ref instanceof Microsoft.Maps.Polyline) {\n            map[mapReference].entities.removeAt(i);\n          }\n        }\n\n        var polylineLocations = polyline.location ? polyline.location : null;\n        var polylineOption = polyline.option ? polyline.option : null;\n        var polylineLocationsAsMapLocations = [];\n\n        for (var polylineLocationIndex = 0; polylineLocationIndex < polylineLocations.length && polylineLocations[polylineLocationIndex][0] && polylineLocations[polylineLocationIndex][1]; polylineLocationIndex++) {\n          polylineLocationsAsMapLocations.push(new Microsoft.Maps.Location(polylineLocations[polylineLocationIndex][0], polylineLocations[polylineLocationIndex][1]));\n        }\n\n        if (polylineLocationsAsMapLocations.length !== 0) {\n          var polylineObject = new Microsoft.Maps.Polyline(polylineLocationsAsMapLocations, polylineOption);\n          map[mapReference].entities.push(polylineObject);\n        }\n      }\n    }\n  }, {\n    key: 'setDirections',\n    value: function setDirections(directions, mapReference) {\n      if (map[mapReference] && directions) {\n        var inputPanel = directions.inputPanel ? directions.inputPanel : null;\n        var renderOptions = directions.renderOptions ? directions.renderOptions : null;\n        var requestOptions = directions.requestOptions ? directions.requestOptions : null;\n        var wayPoints = directions.wayPoints ? directions.wayPoints : [];\n        var wayPointsAsDirection = [];\n        Microsoft.Maps.loadModule('Microsoft.Maps.Directions', function () {\n          var directionsManager = new Microsoft.Maps.Directions.DirectionsManager(map[mapReference]);\n          directionsManager.clearAll();\n\n          if (inputPanel) {\n            directionsManager.showInputPanel(inputPanel);\n          }\n\n          if (renderOptions) {\n            if (renderOptions.itineraryContainer) {\n              renderOptions.itineraryContainer = document.getElementById(renderOptions.itineraryContainer);\n            }\n\n            directionsManager.setRenderOptions(renderOptions);\n          }\n\n          if (requestOptions) {\n            var distanceUnit = requestOptions.distanceUnit ? Microsoft.Maps.Directions.DistanceUnit[requestOptions.distanceUnit] : null;\n            var routeMode = requestOptions.routeMode ? Microsoft.Maps.Directions.RouteMode[requestOptions.routeMode] : null;\n            var routeAvoidance = requestOptions.routeAvoidance ? Microsoft.Maps.Directions.RouteAvoidance[requestOptions.routeAvoidance] : null;\n            var routeOptimization = requestOptions.routeOptimization ? Microsoft.Maps.Directions.RouteOptimization[requestOptions.routeOptimization] : null;\n            var timeType = requestOptions.timeType ? Microsoft.Maps.Directions.TimeTypes[requestOptions.timeType] : null;\n            var vehicleSpec = requestOptions.vehicleSpec ? requestOptions.vehicleSpec : null;\n            var maxRoutes = requestOptions.maxRoutes ? requestOptions.maxRoutes : null;\n            var routeDraggable = requestOptions.routeDraggable ? requestOptions.routeDraggable : null;\n            var routeIndex = requestOptions.routeIndex ? requestOptions.routeIndex : null;\n            var time = requestOptions.time ? requestOptions.time : null;\n            directionsManager.setRequestOptions(Object.assign({}, distanceUnit && {\n              distanceUnit: distanceUnit\n            }, maxRoutes && {\n              maxRoutes: maxRoutes\n            }, routeMode && {\n              routeMode: routeMode\n            }, routeAvoidance && {\n              routeAvoidance: routeAvoidance\n            }, routeOptimization && {\n              routeOptimization: routeOptimization\n            }, timeType && {\n              timeType: timeType\n            }, vehicleSpec && {\n              vehicleSpec: vehicleSpec\n            }, routeDraggable && {\n              routeDraggable: routeDraggable\n            }, routeIndex && {\n              routeIndex: routeIndex\n            }, time && {\n              time: time\n            }));\n          }\n\n          for (var wayPointsIndex = 0; wayPointsIndex < wayPoints.length; wayPointsIndex++) {\n            var address = wayPoints[wayPointsIndex].address ? wayPoints[wayPointsIndex].address : null;\n            var location = wayPoints[wayPointsIndex].location && wayPoints[wayPointsIndex].location[0] && wayPoints[wayPointsIndex].location[1] ? new Microsoft.Maps.Location(wayPoints[wayPointsIndex].location[0], wayPoints[wayPointsIndex].location[1]) : null;\n            var isViaPoint = wayPoints[wayPointsIndex].isViaPoint ? wayPoints[wayPointsIndex].isViaPoint : null;\n            wayPointsAsDirection.push(new Microsoft.Maps.Directions.Waypoint({\n              address: address,\n              location: location,\n              isViaPoint: isViaPoint\n            }));\n          }\n\n          if (wayPointsAsDirection.length !== 0) {\n            for (var wayPointsAsDirectionIndex = 0; wayPointsAsDirectionIndex < wayPointsAsDirection.length; wayPointsAsDirectionIndex++) {\n              directionsManager.addWaypoint(wayPointsAsDirection[wayPointsAsDirectionIndex]);\n            }\n\n            directionsManager.calculateDirections();\n          }\n        });\n      }\n    }\n  }, {\n    key: 'setMapHandlers',\n    value: function setMapHandlers(mapHandlers, mapReference) {\n      if (map[mapReference] && mapHandlers) {\n        for (var mapHandlerIndex = 0; mapHandlerIndex < mapHandlers.length; mapHandlerIndex++) {\n          var mapHandler = mapHandlers[mapHandlerIndex];\n\n          if (mapHandler.addHandler) {\n            Microsoft.Maps.Events.addHandler(map[mapReference], mapHandler.addHandler, function (callback, e) {\n              var callbackData = {\n                event: e,\n                map: map[mapReference]\n              };\n              this.MakeCallback(callback, callbackData);\n            }.bind(this, mapHandler.callback));\n          } else {\n            Microsoft.Maps.Events.addHandler(map[mapReference], \"click\", function (callback, e) {\n              var callbackData = {\n                event: e,\n                map: map[mapReference]\n              };\n              this.MakeCallback(callback, callbackData);\n            }.bind(this, mapHandler.callback));\n          }\n        }\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return _react2.default.createElement('div', {\n        id: this.props.id,\n        className: (0, _classnames2.default)('react-bingmaps', this.props.className)\n      });\n    }\n  }]);\n\n  return ReactBingmaps;\n}(_react.Component);\n\nexports.default = ReactBingmaps;\nReactBingmaps.propTypes = {\n  bingmapKey: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),\n  center: _propTypes2.default.arrayOf(_propTypes2.default.number),\n  mapTypeId: _propTypes2.default.string,\n  navigationBarMode: _propTypes2.default.string,\n  supportedMapTypes: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  heading: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),\n  zoom: _propTypes2.default.number,\n  pushPins: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    location: _propTypes2.default.arrayOf(_propTypes2.default.number),\n    option: _propTypes2.default.object,\n    addHandler: _propTypes2.default.shape({\n      \"type\": _propTypes2.default.string,\n      \"callback\": _propTypes2.default.func\n    })\n  })),\n  disableStreetside: _propTypes2.default.bool,\n  infoboxes: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    location: _propTypes2.default.arrayOf(_propTypes2.default.number),\n    option: _propTypes2.default.object,\n    addHandler: _propTypes2.default.shape({\n      \"type\": _propTypes2.default.string,\n      \"callback\": _propTypes2.default.func\n    })\n  })),\n  infoboxesWithPushPins: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    location: _propTypes2.default.arrayOf(_propTypes2.default.number),\n    addHandler: _propTypes2.default.string,\n    infoboxOption: _propTypes2.default.object,\n    pushPinOption: _propTypes2.default.object,\n    infoboxAddHandler: _propTypes2.default.shape({\n      \"type\": _propTypes2.default.string,\n      \"callback\": _propTypes2.default.func\n    }),\n    pushPinAddHandler: _propTypes2.default.shape({\n      \"type\": _propTypes2.default.string,\n      \"callback\": _propTypes2.default.func\n    })\n  })),\n  getLocation: _propTypes2.default.object,\n  regularPolygons: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    center: _propTypes2.default.arrayOf(_propTypes2.default.number),\n    radius: _propTypes2.default.number,\n    points: _propTypes2.default.number,\n    option: _propTypes2.default.object\n  })),\n  boundary: _propTypes2.default.shape({\n    location: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.number), _propTypes2.default.arrayOf(_propTypes2.default.string)]),\n    option: _propTypes2.default.object,\n    polygonStyle: _propTypes2.default.object,\n    search: _propTypes2.default.string\n  }),\n  mapOptions: _propTypes2.default.object,\n  polyline: _propTypes2.default.shape({\n    location: _propTypes2.default.arrayOf(_propTypes2.default.arrayOf(_propTypes2.default.number)),\n    option: _propTypes2.default.object\n  }),\n  directions: _propTypes2.default.object,\n  mapHandlers: _propTypes2.default.arrayOf(_propTypes2.default.object)\n};\nReactBingmaps.defaultProps = {\n  bingmapKey: undefined,\n  center: undefined,\n  mapTypeId: undefined,\n  navigationBarMode: undefined,\n  supportedMapTypes: undefined,\n  heading: 0,\n  pushPins: undefined,\n  disableStreetside: true,\n  infoboxes: undefined,\n  infoboxesWithPushPins: undefined,\n  zoom: undefined,\n  getLocation: undefined,\n  regularPolygons: undefined,\n  boundary: undefined,\n  mapOptions: undefined,\n  polyline: undefined,\n  directions: undefined,\n  mapHandlers: undefined\n};","map":null,"metadata":{},"sourceType":"script"}